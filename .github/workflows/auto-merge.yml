name: Auto Merge Copilot PRs

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
  workflow_run:
    workflows: ["CI"]
    types: [completed]

jobs:
  auto-approve-and-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve and merge Copilot PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.COPILOT_PAT }}
          script: |
            let prNumber;
            let headSha;

            // Get PR number based on event type
            if (context.eventName === "pull_request_target") {
              prNumber = context.payload.pull_request.number;
              headSha = context.payload.pull_request.head.sha;
            } else if (context.eventName === "workflow_run") {
              const prs = context.payload.workflow_run.pull_requests;
              if (!prs || prs.length === 0) {
                console.log("No PRs associated with this workflow run");
                return;
              }
              prNumber = prs[0].number;
              headSha = context.payload.workflow_run.head_sha;
            }

            if (!prNumber) {
              console.log("No PR found");
              return;
            }

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Only process PRs from Copilot
            if (pr.user.login !== "copilot-swe-agent[bot]") {
              console.log("PR is not from Copilot, skipping");
              return;
            }

            if (pr.state !== "open") {
              console.log("PR is not open");
              return;
            }

            console.log("Processing Copilot PR #" + prNumber);

            // Wait a moment for checks to register
            await new Promise(resolve => setTimeout(resolve, 5000));

            // Get check runs for the PR
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });

            console.log("Found " + checks.check_runs.length + " check runs");

            // Filter out this workflow's own check
            const relevantChecks = checks.check_runs.filter(
              check => !check.name.includes("Auto")
            );

            // Check if all relevant checks passed
            const allCompleted = relevantChecks.every(check => check.status === "completed");
            const allPassed = relevantChecks.every(
              check => check.status === "completed" &&
                       (check.conclusion === "success" || check.conclusion === "skipped")
            );

            console.log("All completed: " + allCompleted + ", All passed: " + allPassed);

            if (!allCompleted) {
              console.log("Not all checks completed yet");
              return;
            }

            if (!allPassed) {
              console.log("Some checks failed");
              return;
            }

            // Auto-approve the PR
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: "APPROVE",
                body: "Auto-approved: All CI checks passed."
              });
              console.log("Approved PR #" + prNumber);
            } catch (error) {
              console.log("Approval note: " + error.message);
            }

            // Merge the PR
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: "squash"
              });
              console.log("Successfully merged PR #" + prNumber);
            } catch (error) {
              console.log("Merge failed: " + error.message);
            }
